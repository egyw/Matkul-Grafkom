<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo Raytrace Dasar - 1 Bola</title>
    <style>
        body { margin: 20px; font-family: sans-serif; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: white; display: block; margin: 0 auto; }
        h1, p { text-align: center; }
    </style>
    <!-- 1. Include gl-matrix library from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.3/gl-matrix-min.js"></script>
</head>
<body>

    <h1>Demo Raytrace Dasar (Sphere Intersection)</h1>
    <p>Menampilkan intersection ray dengan 1 bola menggunakan Canvas 2D.</p>
    <!-- 2. Canvas Element -->
    <canvas id="raytraceCanvas" width="500" height="500"></canvas>

    <script>
        // Konfigurasi dasar
        const CANVAS_WIDTH = 500;
        const CANVAS_HEIGHT = 500;

        // --- Helper Functions (Menggunakan gl-matrix) ---
        // Meskipun dalam satu file, kita kelompokkan seolah-olah terpisah
        const vec3 = glMatrix.vec3; // Alias untuk kemudahan

        /**
         * Menghitung intersection antara sebuah ray dan sphere.
         * Mengembalikan nilai t (jarak) jika ada intersection, atau null jika tidak.
         * @param {vec3} rayOrigin - Titik asal ray.
         * @param {vec3} rayDirection - Vektor arah ray (harus normalized).
         * @param {vec3} sphereCenter - Pusat bola.
         * @param {number} sphereRadius - Radius bola.
         * @returns {number | null} Jarak t ke intersection terdekat, atau null.
         */
        function intersectSphere(rayOrigin, rayDirection, sphereCenter, sphereRadius) {
            const L = vec3.create(); // Vektor dari pusat bola ke asal ray
            vec3.subtract(L, rayOrigin, sphereCenter);

            const a = vec3.dot(rayDirection, rayDirection); // Harus 1 jika rayDirection normalized
            const b = 2.0 * vec3.dot(rayDirection, L);
            const c = vec3.dot(L, L) - (sphereRadius * sphereRadius);

            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) {
                return null; // Tidak ada intersection
            } else {
                const t0 = (-b - Math.sqrt(discriminant)) / (2.0 * a);
                const t1 = (-b + Math.sqrt(discriminant)) / (2.0 * a);

                // Kita inginkan intersection terdekat di depan kamera (t > 0)
                if (t0 > 0.001) { // Gunakan epsilon kecil untuk menghindari self-intersection
                    return t0;
                } else if (t1 > 0.001) {
                    return t1;
                } else {
                    return null; // Kedua intersection di belakang atau tepat di origin
                }
            }
        }
        // --- End Helper Functions ---


        // --- Main Raytracing Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('raytraceCanvas');
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Could not get 2D context!");
                return;
            }

            const imageData = ctx.createImageData(CANVAS_WIDTH, CANVAS_HEIGHT);
            const data = imageData.data; // Uint8ClampedArray [R, G, B, A, R, G, B, A, ...]

            // Definisi Scene
            const eyePosition = vec3.fromValues(0, 0, 0); // Kamera di origin
            const sphere = {
                center: vec3.fromValues(0, 0, -5), // Tengah layar, 5 unit di depan kamera
                radius: 1.5, // Radius bola
                color: [255, 0, 0] // Warna Merah (R, G, B)
            };

            // Vektor temporary untuk perhitungan (agar tidak membuat objek baru di loop)
            const tempVec = vec3.create();
            const rayDirection = vec3.create();
            const pixelWorldPos = vec3.create();

            // Mulai Raytracing per pixel
            console.time("Raytracing Time"); // Ukur waktu render

            for (let y = 0; y < CANVAS_HEIGHT; y++) {
                for (let x = 0; x < CANVAS_WIDTH; x++) {
                    // 1. Konversi koordinat pixel (x, y) ke koordinat world space
                    //    pada view plane (misal di z = -1)
                    //    Map x from [0, width-1] to [-aspect, aspect]
                    //    Map y from [0, height-1] to [1, -1] (canvas Y terbalik)
                    const aspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
                    pixelWorldPos[0] = (x / (CANVAS_WIDTH - 1) * 2 - 1) * aspectRatio;
                    pixelWorldPos[1] = (1 - y / (CANVAS_HEIGHT - 1) * 2);
                    pixelWorldPos[2] = -1; // Posisi view plane

                    // 2. Hitung arah ray dari mata ke titik di view plane
                    vec3.subtract(rayDirection, pixelWorldPos, eyePosition);
                    vec3.normalize(rayDirection, rayDirection);

                    // 3. Cek intersection dengan bola
                    const t = intersectSphere(eyePosition, rayDirection, sphere.center, sphere.radius);

                    // 4. Tentukan warna pixel
                    const pixelIndex = (y * CANVAS_WIDTH + x) * 4; // Index R dalam array data
                    if (t !== null && t > 0) {
                        // Ada intersection -> Warnai pixel sesuai warna bola
                        data[pixelIndex]     = sphere.color[0]; // R
                        data[pixelIndex + 1] = sphere.color[1]; // G
                        data[pixelIndex + 2] = sphere.color[2]; // B
                        data[pixelIndex + 3] = 255;           // A (Opaque)
                    } else {
                        // Tidak ada intersection -> Warna background (misal hitam)
                        data[pixelIndex]     = 0;   // R
                        data[pixelIndex + 1] = 0;   // G
                        data[pixelIndex + 2] = 0;   // B
                        data[pixelIndex + 3] = 255; // A
                    }
                }
            }
            console.timeEnd("Raytracing Time");

            // 5. Gambar hasil ke canvas
            ctx.putImageData(imageData, 0, 0);

            console.log("Raytracing selesai.");
        });
        // --- End Main Raytracing Logic ---

    </script>

</body>
</html>