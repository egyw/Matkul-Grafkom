<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo Raytracer Dasar - Intersection (Configurable)</title>
    <style>
        body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f0f0f0; margin: 0; }
        canvas { border: 1px solid black; /* Background color will be set by config */ }
    </style>
    <!-- Include gl-matrix library -->
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script>
</head>
<body>
    <canvas id="raytraceCanvas"></canvas> <!-- Ukuran diatur oleh JS -->

    <script>
        // ======================================================
        // KONFIGURASI SCENE (Format JSON-like)
        // ======================================================
        const config = {
            canvas: {
                width: 500,
                height: 500
            },
            camera: {
                origin: [0, 0, -2] // Posisi mata kamera [x, y, z]
            },
            scene: {
                // Warna background default jika sinar tidak mengenai objek [R, G, B]
                backgroundColor: [208, 224, 240], // Biru muda
                objects: [
                    {
                        type: 'sphere',                // Tipe objek
                        center: [0, 0, 3],             // Posisi tengah [x, y, z]
                        radius: 1.0,                   // Jari-jari
                        color: [255, 0, 0]             // Warna [R, G, B] (Merah)
                    }
                    // --- Tambahkan objek lain di sini ---
                    // Contoh:
                    // {
                    //     type: 'sphere',
                    //     center: [-1.5, 0, 4],
                    //     radius: 0.5,
                    //     color: [0, 255, 0] // Hijau
                    // },
                    // {
                    //     type: 'sphere',
                    //     center: [1.5, -0.5, 3.5],
                    //     radius: 0.8,
                    //     color: [0, 0, 255] // Biru
                    // }
                ]
            }
        };
        // ======================================================
        // AKHIR KONFIGURASI
        // ======================================================


        // --- Setup Awal ---
        const canvas = document.getElementById('raytraceCanvas');
        const ctx = canvas.getContext('2d');

        // Set ukuran canvas dari config
        canvas.width = config.canvas.width;
        canvas.height = config.canvas.height;
        // Set warna background canvas (sebagai fallback awal)
        canvas.style.backgroundColor = `rgb(${config.scene.backgroundColor.join(',')})`;

        const width = canvas.width;
        const height = canvas.height;
        const imageData = ctx.createImageData(width, height);
        const pixels = imageData.data; // Array [R, G, B, A, R, G, B, A, ...]

        // --- Alias untuk gl-matrix ---
        const vec3 = glMatrix.vec3;

        // --- Helper: Fungsi Intersection (Konsep dari "helper.js") ---

        /**
         * Menghitung persimpangan antara sinar (ray) dan bola (sphere).
         * @param {object} ray - Objek sinar { origin: vec3, direction: vec3 }
         * @param {object} sphere - Objek bola { center: vec3, radius: number, color: [r,g,b] }
         * @returns {number} Jarak t ke titik persimpangan terdekat, atau Infinity jika tidak ada persimpangan.
         */
        function intersectSphere(ray, sphere) {
            const oc = vec3.create();
            vec3.subtract(oc, ray.origin, sphere.center);

            const a = vec3.dot(ray.direction, ray.direction);
            const b = 2.0 * vec3.dot(oc, ray.direction);
            const c = vec3.dot(oc, oc) - sphere.radius * sphere.radius;
            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) {
                return Infinity;
            } else {
                const sqrtDiscriminant = Math.sqrt(discriminant);
                const t1 = (-b - sqrtDiscriminant) / (2.0 * a);
                const t2 = (-b + sqrtDiscriminant) / (2.0 * a);
                const epsilon = 0.001;

                if (t1 > epsilon && (t1 < t2 || t2 <= epsilon)) { // t1 is the closest valid hit
                    return t1;
                }
                if (t2 > epsilon) { // t2 is the closest valid hit
                    return t2;
                }
                return Infinity; // Both hits are behind or too close
            }
        }

        // --- Inisialisasi Scene dari Config ---
        const camera = {
            origin: vec3.fromValues(...config.camera.origin) // Konversi array ke vec3
        };

        // Proses objek dari config menjadi format yang siap digunakan (dengan vec3)
        const sceneObjects = config.scene.objects.map(objConfig => {
            const processedObj = { ...objConfig }; // Salin properti dasar
            if (processedObj.type === 'sphere') {
                processedObj.center = vec3.fromValues(...objConfig.center); // Konversi center
            }
            // Tambahkan konversi untuk tipe objek lain di sini jika ada
            return processedObj;
        }).filter(obj => obj !== null); // Filter jika ada tipe yg tidak disupport

        const backgroundColor = config.scene.backgroundColor;

        // --- Fungsi Raytracing Utama ---

        /**
         * Melakukan trace sinar untuk satu pixel dan menentukan warnanya.
         * @param {object} ray - Sinar yang akan di-trace { origin: vec3, direction: vec3 }
         * @returns {[r,g,b]|null} Warna objek yang terkena sinar, atau null jika tidak ada.
         */
        function traceRay(ray) {
            let closestT = Infinity;
            let hitObject = null;

            for (const obj of sceneObjects) {
                let t = Infinity;
                // Panggil fungsi intersection berdasarkan tipe objek
                if (obj.type === 'sphere') {
                   t = intersectSphere(ray, obj);
                }
                // Tambahkan 'else if (obj.type === 'plane')' dst. di sini

                // Cek apakah ini intersection terdekat sejauh ini
                if (t < closestT) {
                    closestT = t;
                    hitObject = obj;
                }
            }

            if (hitObject) {
                return hitObject.color;
            } else {
                return null; // Kena background
            }
        }

        // --- Render Loop ---
        function renderScene() {
            console.time("RenderTime");

            const aspectRatio = width / height;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const u = x / (width - 1);
                    const v = y / (height - 1);
                    const screenX = (2.0 * u - 1.0) * aspectRatio;
                    const screenY = 1.0 - 2.0 * v; // Y dibalik

                    const ray = {
                        origin: vec3.clone(camera.origin),
                        direction: vec3.create()
                    };
                    const targetPoint = vec3.fromValues(screenX, screenY, 0);
                    vec3.subtract(ray.direction, targetPoint, ray.origin);
                    vec3.normalize(ray.direction, ray.direction);

                    const color = traceRay(ray);

                    const pixelIndex = (y * width + x) * 4;

                    if (color) {
                        pixels[pixelIndex + 0] = color[0]; // R
                        pixels[pixelIndex + 1] = color[1]; // G
                        pixels[pixelIndex + 2] = color[2]; // B
                        pixels[pixelIndex + 3] = 255;       // A
                    } else {
                        // Gunakan warna background dari config
                        pixels[pixelIndex + 0] = backgroundColor[0]; // R
                        pixels[pixelIndex + 1] = backgroundColor[1]; // G
                        pixels[pixelIndex + 2] = backgroundColor[2]; // B
                        pixels[pixelIndex + 3] = 255;       // A
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            console.timeEnd("RenderTime");
            console.log("Render selesai.");
        }

        // --- Jalankan Render ---
        renderScene();

    </script>
</body>
</html>